---
kernelspec:
  name: python3
  display_name: 'Python 3.14'
---
# Chapter 1: Algorithm

## Algorithm
_"It is a set of well defined steps, which are followed to solve a problem"_

Example:
1. Brushing Teeth
2. Making Tea
3. Determine best profit for thief in a Knapsack
4. Help salesperson travel all cities with minimal cost to meet monthly targets

### Characteristics of an Algorithm
There are 5 key characteristics of an algorithm:-
#### 1. Definiteness
* Every step is meaningful and unambiguous for the reader.
* For example: Increase value of $x$ by $1$, instead of make $x$ bigger.

#### 2. Finiteness
* Every algorithm must have finite number of steps.

#### 3. Input
* An algorithm must accept zero or more inputs.

#### 4. Output
* It must produce atleast one output.

#### 5. Effectiveness 
* It must be followed easily, even with pen and paper.

## Pseudo Code
1. It is the most effective way to represent an algorithm.
2. It is in normal english language.
3. It is written as a sequence of steps.

Example:
### Psuedo code for making a Tea

Steps are as follows:-
1. Get:
    1. A $\frac{3}{4}$ cup of drinking water
    2. A vessel (_patila_)
    3. A $\frac{1}{2}$ tea spoon of tea leaves (_chai patti_)
    4. Ginger (1 gram)
    5. 2 tea spoons of sugar
    6. A $\frac{1}{2}$ cup of milk
    7. Filter (_channi_)
2. Light the stove to medium flame and place vessel.
3. Put $\frac{3}{4}$ cup of water.
4. Add tea leaves, crushed ginger and sugar.
5. Wait till water begins to boil.
6. Add milk
7. Once the solution begins to boil, and comes to the brim of the vessel, turn off the flame.
8. Now, filter the tea from vessel to cup.

This is how we write Pseudo Code of a problem!

## Performance Analysis
1. Actually, we have discussed only way of making a tea.
2. Here, we have allocated our ingredients before, then prepared the tea.
3. So, it make our process faster, but used up too many resources such as:
    1. 2 cups for water and milk
    2. 3 tea spoons for tea leaves and sugar
4. Instead of using 2 cups, we can use just 1 cup to put water first, then, milk.
5. We can solve the same approach the other way, where we will access ingredients and resources when required, no pre-allocations!
6. Now, this will save our resources, but increase time spent to make a tea, because there will be extra time to get resources and ingredients.
7. Similarly, for other approaches, to make the same tea, we analyse their performance based on their:
    1. Time, and
    2. Space
8. And, this is what we study in this subject, when we go for analysis part of an algorithm.
9. We look for their:
    1. Time Complexity
        * It is the time taken by an algorithm to solve our problem.
    2. Space Complexity
        * It is the space taken by algorithm to solve a problem.

### Order of Function
1. Sometimes, we compare bunch of algorithms together, some are slower, some are faster, while other takes almost same time and space.
2. Suppose if we have algorithms $A$, $B$, $C$ and $D$
    1. If we come with a time comparisons of these algorithms, at an instant, for an input size of 8, we have:
        1. $A$ takes 2 milliseconds
        2. $B$ takes 4 milliseconds
        3. $C$ takes 1 milliseconds
        4. $D$ takes 8 milliseconds
    2. Now, we want to compare it for all input sizes till infinity $\infty$
    3. We will get a vast table for comaprisons among these values, and we plot a graph.

    ```
    [ Show graphs of A, B, C and D] as n, n^2, n and 2^n with label for time
    ```
    4. But, NONE of us wants to REMEMBER THIS!
3. So, we remember the order of their functions, for example, for the graph like this:

    * We say it's graph of $n^2$
    * In algorithm, it has nested loops, like below, in triangle.
    ```{code}
    for(int i=0; i<5; i++) {
        for (int j=0; j<i+1; j++) {
            cout << "*";
        }
        cout << endl;
    }
    ```

    ```{code-cell}
    :tag: remove-input
    for i in range(1, 6):
        print("*"*i)
    ```
4. Similarly, we have other order of functions defined as follows:
    ```{csv-table} 
    :header: "Order of Function", "Their Meaning"

    "$1$", "Constant time to solve for input of any size"
    "n", "rate of growth in time/space same as input size growth"
    "$n^2$", "loop in a loop"
    "$n^3$", "loop in a loop in a loop"
    "$log(n)$", "Problem getting divided into halves, like binary search"
    "$nlog(n)$", "one part grows as $n$, other as $log(n)$, like merge sort"
    "$2^n$", "Time/Space increasing exponentially, like Travelling Salesperson problem"
    ```
### Asymptotic Notation
1. Our algorithms need not to act the same always.
2. For instance, a Binary Search NOT always takes $log(n)$ time to search an element, sometimes, we find element on first check.
3. In that case, Order of function would be $1$.
4. So, our algorithm have:
    1. Best Case Scenario - best performance
    2. Worst Case Scenario - worst performance
    3. Average Case Scenario - average performance
5. For this, we have a mathematical framework, named Asymptotic Notation.
    #### Defination
    _"It is a mathematical framework which is used to analyse an algorithm for its efficiency as input size $(n)$ grows to infinity $(\infty)$"_
6. There are 3 types of Asymptotic Notations:-
    1. Big O notation (Worst Case)
    2. Big Omega $(\Omega)$ notation (Best Case)
    3. Big Theta $(\Theta)$ notation (Average Case)

#### Big O Notation
```
    Big O graph goes here

    with caption below the graph as:
    Here, n0 -> Threshold size of input (i.e. minimum input size, after which functions (algorithms) show their true behavior)
    f(n) -> Our function (algorithm) which is under analysis.
    g(n) -> Another function (algorithm) having higher rate of growth than our function (algorithm)
```
Due to above graph, it is also known as **Upper Bound**.
##### Defination
_A function $f(n)$ is said to be $O(g(n))$, if there exists positive constants, c & $n_{0}$, such that:_
$$ 0 \leq f(n) \leq c(g(n)); \forall n \geq n_{0}$$

1. It means, how **bad** our algorithm will perform, as input size grows.
2. High rate of growth, is a **bad sign**, for an algorithm.

#### Big Omege $(\Omega)$ Notation
```
    Big Omega graph goes here

    with caption below the graph as:
    Here, n0 -> Threshold size of input (i.e. minimum input size, after which functions (algorithms) show their true behavior)
    f(n) -> Our function (algorithm) which is under analysis.
    g(n) -> Another function (algorithm) having lower rate of growth than our function (algorithm)
```
Due to above graph, it is also known as **Lower Bound**.
##### Defination
_A function $f(n)$ is said to be $\Omega(g(n))$, if there exists positive constants, c & $n_{0}$, such that:_
$$ 0 \leq c(g(n)) \leq f(n); \forall n \geq n_{0}$$

1. It means, how **best** our algorithm will perform, as input size grows.
2. Lower the rate of growth, is **better**.

#### Big Theta $(\Theta)$ Notation
```
    Big Theta graph goes here

    with caption below the graph as:
    Here, n0 -> Threshold size of input (i.e. minimum input size, after which functions (algorithms) show their true behavior)
    f(n) -> Our function (algorithm) which is under analysis.
    g(n) -> Another function (algorithm) having lower rate of growth than our function (algorithm)
```
Due to above graph, it is also known as **Tight Bound**.
##### Defination
_A function $f(n)$ is said to be $\Theta(g(n))$, if there exists positive constants, $c_{1}$, $c_{2}$ & $n_{0}$, such that:_
$$ 0 \leq c_{1}(g(n)) \leq f(n) \leq c_{2}(g(n)); \forall n \geq n_{0}$$

1. It means, **average** performance of an algorithm.
2. Lies between Upper bound and Lower bound.

### Elementary Data Structures
#### Stack
```
    Stack Diagram goes here
```
<!-- Add separation -->
```{figure} ./1.jpg
This is a caption in **Markdown**
```


1. It is a linear data structure, i.e. elements are accessed one after another, like we have place plates one over another in wedding.
2. It has only end for storing (Push) and removing (Pop) an element.
3. It operates on LIFO (Last In First Out) principle.
4. Structure of a stack:
    1. TOP - It is a pointer to the topmost element of the stack.
    2. IN - It is the input direction of an element on the top of the stack.
    3. OUT - It is the output direction of an element from the top of the stack.
5. Stack has **Capacity** (MAX) associated with it, which shows the maximum elements it can store.
    

##### Operations on Stack
1. **Push**
    * It refers to storing element on the top of the stack.
    * During push, TOP get incremented by 1, and we store element at that location, with:
        ```{code} 
        TOP++;
        stack[TOP] = element;
        ```
2. **Pop**
    * It refers to removing element from the top of the stack.
    * During pop, we simply decrement TOP by 1
        ```{code}
        TOP--;
        ```
3. **Peek**
    * It refers to view the TOP element of stack, with:
        ```{code}
        stack[TOP];
        ```

4. **isEmpty**
    * It checks whether stack is empty or not.
    * It returns boolean value: 0 (false) / 1 (true)
        ```{code}
        if (TOP == -1) then
            return 1; // i.e. stack is empty
        else
            return 0; // i.e. stack is not empty
        ```
5. **isFull**
    * It checks whether stack is full or not.
    * It returns boolean value: 0 (false) / 1 (true)
        ```{code}
        MAX is the limit of the stack.

        if (TOP == MAX) then
            return 1; // i.e. stack is full
        else
            return 0; // i.e. stack is not full
        ```

#### Queue
```
    Queue Diagram goes here
```
<!-- Add separation -->
```{figure} ./1.jpg
This is a caption in **Markdown**
```

1. It is a linear data structure, i.e. elements are accessed one after another, like we have place plates one over another in wedding.
2. It has 2 ends (front and rear).
3. REAR is for storing elements, and FRONT is for removing elements. (It's a choice, we can change it) 
3. It operates on FIFO (First In First Out) principle.
4. Queue has **Capacity** associated with it, which is the maximum element it can store in it.
5. Structure of a Queue:
    1. REAR
        1. It is a pointer to the rear of the Queue.
        2. It gets incremented by 1, when we add an element to Queue.
        3. It stops, when REAR becomes equal to Capacity.
    2. FRONT 
        1. It is a pointer to the front of the Queue.
        2. It gets incremented by 1, when we remove an element from Queue.
        3. It stops, when FRONT becomes equal to REAR.

    

##### Operations on Queue
1. **Enqueue**
    * It refers to storing element to the REAR of the Queue.
    * During enqueue, REAR get incremented by 1, and we store element at that location, with:
        ```{code} 
        REAR++;
        Queue[REAR] = element;
        ```
2. **Dequeue**
    * It refers to removing element from the FRONT of the Queue.
    * During dequeue, we simply increment FRONT by 1
        ```{code}
        FRONT++
        ```
3. **getFront**
    * It refers to view the FRONT element of Queue, with:
        ```{code}
        queue[FRONT];
        ```

4. **getRear**
    * It refers to view the REAR element of Queue, with:
        ```{code}
        queue[REAR];
        ```
4. **isEmpty**
    * It checks whether Queue is empty or not.
    * if FRONT > REAR, then Queue is empty.
    * It returns boolean value: 0 (false) / 1 (true)
        ```{code}
        if (FRONT > REAR) then
            return 1; // i.e. Queue is empty
        else
            return 0; // i.e. Queue is not empty
        ```
5. **isFull**
    * It checks whether Queue is full or not.
    * If REAR is equal to Capacity, then Queue if full.
    * It returns boolean value: 0 (false) / 1 (true)
        ```{code}
        CAPACITY is the limit of the stack.

        if (REAR == CAPACITY) then
            return 1; // i.e. queue is full
        else
            return 0; // i.e. queue is not full
        ```

#### Tree
1. It is a non-linear data structure.
2. It is designed as a parent-child relationship, so it is a **hierarichal** data structure.
```
Tree diagram goes here
```
##### Terminologies 
1. **Node** - It is a storage unit in tree, which contains values and pointer to predecessor node & successor nodes.
    ```
    Node diagram goes here
    ```
2. **Edge** - It is a link between 2 nodes, as A & B are connected by an edge.
   
3. **Parent Node** - An immediate predecessor (i.e. previous node) of a node, as C is Parent node of F.

4. **Child Node** - An immediate successor (i.e. next node) of a node, as F is Child node of C.

5. **Leaf Node** - It is the node which has no further child node, as F is a Leaf node.

6. **Subtree** - A tree which is a subset of given tree, see the diagram above.

7. **Root Node** - The topmost node which is the predessor of all nodes.

##### Characteristics
1. **Depth of a node**
    * Number of edges from root to a given node
    * For example, Depth of node E is 2, in diagram above.
2. **Number of Edges**
    * It is the total number of edges in the tree.
    * If number of nodes in a tree are $n$, then
        $$ number of edges, e = n - 1 $$
    * For example, there are 7 nodes, and 6 edges in the tree above.
3. **Height of a Tree**
    * It is the longest path in the tree, i.e. number of edges from root node to leaf nodes is the highest.
    * For example, in the tree above, height of the tree is 2.
4. **Degree**
    * It is number of children a node has.
    * For example, Node B has degree of 2, while leaf nodes has degree of 0.

#### Graph
```
Graph diagram goes here
```
1. It is a non-linear data structure.
2. Unlike other data structures, there is no hard and fast rule about what must be the first node, placement of node and its traversal.
3. Any node can participate a graph at a time.
4. But, there is only one rule that:

    _we must reach all nodes connected to given node using the given edge only once._
5. So, keep record of all vertices and edges, we have a set of vertices as $V$ and a set of edges as $E$.

##### Defination
_A graph, $G$, is represented as_ $ G = (V, E)  $, _where, V is set of vertices (nodes), and E is the set of edges_

1. For example, Social Media.
2. There is no rule to add us as a user, every account has equal importance.
3. But, when we are a part of an university, we are under an hierarchy (tree data structure), like student to Class Representative to Class Teacher to HOD and so on.

##### Types of Graph
1. A graph has various types, on the basis of:
    1. Direction
        1. Directed Graph
        2. Undirected Graph
        ``` 
        Diagram will go here.
        ```
    2. Weight
        1. Weighted Graph
        2. Unweighted Graph
        ```
        Diagram will go here.
        ```