{"version":"1","records":[{"hierarchy":{"lvl1":"Chapter 1: Algorithm"},"type":"lvl1","url":"/chapter-1-alogrithm","position":0},{"hierarchy":{"lvl1":"Chapter 1: Algorithm"},"content":"","type":"content","url":"/chapter-1-alogrithm","position":1},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl2":"Algorithm"},"type":"lvl2","url":"/chapter-1-alogrithm#algorithm","position":2},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl2":"Algorithm"},"content":"“It is a set of well defined steps, which are followed to solve a problem”\n\nExample:\n\nBrushing Teeth\n\nMaking Tea\n\nDetermine best profit for thief in a Knapsack\n\nHelp salesperson travel all cities with minimal cost to meet monthly targets","type":"content","url":"/chapter-1-alogrithm#algorithm","position":3},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"type":"lvl3","url":"/chapter-1-alogrithm#characteristics-of-an-algorithm","position":4},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"content":"There are 5 key characteristics of an algorithm:-","type":"content","url":"/chapter-1-alogrithm#characteristics-of-an-algorithm","position":5},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"1. Definiteness","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"type":"lvl4","url":"/chapter-1-alogrithm#id-1-definiteness","position":6},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"1. Definiteness","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"content":"Every step is meaningful and unambiguous for the reader.\n\nFor example: Increase value of x by 1, instead of make x bigger.","type":"content","url":"/chapter-1-alogrithm#id-1-definiteness","position":7},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"2. Finiteness","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"type":"lvl4","url":"/chapter-1-alogrithm#id-2-finiteness","position":8},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"2. Finiteness","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"content":"Every algorithm must have finite number of steps.","type":"content","url":"/chapter-1-alogrithm#id-2-finiteness","position":9},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"3. Input","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"type":"lvl4","url":"/chapter-1-alogrithm#id-3-input","position":10},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"3. Input","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"content":"An algorithm must accept zero or more inputs.","type":"content","url":"/chapter-1-alogrithm#id-3-input","position":11},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"4. Output","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"type":"lvl4","url":"/chapter-1-alogrithm#id-4-output","position":12},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"4. Output","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"content":"It must produce atleast one output.","type":"content","url":"/chapter-1-alogrithm#id-4-output","position":13},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"5. Effectiveness","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"type":"lvl4","url":"/chapter-1-alogrithm#id-5-effectiveness","position":14},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"5. Effectiveness","lvl3":"Characteristics of an Algorithm","lvl2":"Algorithm"},"content":"It must be followed easily, even with pen and paper.","type":"content","url":"/chapter-1-alogrithm#id-5-effectiveness","position":15},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl2":"Pseudo Code"},"type":"lvl2","url":"/chapter-1-alogrithm#pseudo-code","position":16},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl2":"Pseudo Code"},"content":"It is the most effective way to represent an algorithm.\n\nIt is in normal english language.\n\nIt is written as a sequence of steps.\n\nExample:","type":"content","url":"/chapter-1-alogrithm#pseudo-code","position":17},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Psuedo code for making a Tea","lvl2":"Pseudo Code"},"type":"lvl3","url":"/chapter-1-alogrithm#psuedo-code-for-making-a-tea","position":18},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Psuedo code for making a Tea","lvl2":"Pseudo Code"},"content":"Steps are as follows:-\n\nGet:\n\nA \\frac{3}{4} cup of drinking water\n\nA vessel (patila)\n\nA \\frac{1}{2} tea spoon of tea leaves (chai patti)\n\nGinger (1 gram)\n\n2 tea spoons of sugar\n\nA \\frac{1}{2} cup of milk\n\nFilter (channi)\n\nLight the stove to medium flame and place vessel.\n\nPut \\frac{3}{4} cup of water.\n\nAdd tea leaves, crushed ginger and sugar.\n\nWait till water begins to boil.\n\nAdd milk\n\nOnce the solution begins to boil, and comes to the brim of the vessel, turn off the flame.\n\nNow, filter the tea from vessel to cup.\n\nThis is how we write Pseudo Code of a problem!","type":"content","url":"/chapter-1-alogrithm#psuedo-code-for-making-a-tea","position":19},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl2":"Performance Analysis"},"type":"lvl2","url":"/chapter-1-alogrithm#performance-analysis","position":20},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl2":"Performance Analysis"},"content":"Actually, we have discussed only way of making a tea.\n\nHere, we have allocated our ingredients before, then prepared the tea.\n\nSo, it make our process faster, but used up too many resources such as:\n\n2 cups for water and milk\n\n3 tea spoons for tea leaves and sugar\n\nInstead of using 2 cups, we can use just 1 cup to put water first, then, milk.\n\nWe can solve the same approach the other way, where we will access ingredients and resources when required, no pre-allocations!\n\nNow, this will save our resources, but increase time spent to make a tea, because there will be extra time to get resources and ingredients.\n\nSimilarly, for other approaches, to make the same tea, we analyse their performance based on their:\n\nTime, and\n\nSpace\n\nAnd, this is what we study in this subject, when we go for analysis part of an algorithm.\n\nWe look for their:\n\nTime Complexity\n\nIt is the time taken by an algorithm to solve our problem.\n\nSpace Complexity\n\nIt is the space taken by algorithm to solve a problem.","type":"content","url":"/chapter-1-alogrithm#performance-analysis","position":21},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Order of Function","lvl2":"Performance Analysis"},"type":"lvl3","url":"/chapter-1-alogrithm#order-of-function","position":22},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Order of Function","lvl2":"Performance Analysis"},"content":"Sometimes, we compare bunch of algorithms together, some are slower, some are faster, while other takes almost same time and space.\n\nSuppose if we have algorithms A, B, C and D\n\nIf we come with a time comparisons of these algorithms, at an instant, for an input size of 8, we have:\n\nA takes 2 milliseconds\n\nB takes 4 milliseconds\n\nC takes 1 milliseconds\n\nD takes 8 milliseconds\n\nNow, we want to compare it for all input sizes till infinity \\infty\n\nWe will get a vast table for comaprisons among these values, and we plot a graph.[ Show graphs of A, B, C and D] as n, n^2, n and 2^n with label for time\n\nBut, NONE of us wants to REMEMBER THIS!\n\nSo, we remember the order of their functions, for example, for the graph like this:\n\nWe say it’s graph of n^2\n\nIn algorithm, it has nested loops, like below, in triangle.for(int i=0; i<5; i++) {\n    for (int j=0; j<i+1; j++) {\n        cout << \"*\";\n    }\n    cout << endl;\n}\n\nfor i in range(1, 6):\n    print(\"*\"*i)\n\n\n\nSimilarly, we have other order of functions defined as follows:\n\nOrder of Function\n\nTheir Meaning\n\n1\n\nConstant time to solve for input of any size\n\nn\n\nrate of growth in time/space same as input size growth\n\nn^2\n\nloop in a loop\n\nn^3\n\nloop in a loop in a loop\n\nlog(n)\n\nProblem getting divided into halves, like binary search\n\nnlog(n)\n\none part grows as n, other as log(n), like merge sort\n\n2^n\n\nTime/Space increasing exponentially, like Travelling Salesperson problem","type":"content","url":"/chapter-1-alogrithm#order-of-function","position":23},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl3","url":"/chapter-1-alogrithm#asymptotic-notation","position":24},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"Our algorithms need not to act the same always.\n\nFor instance, a Binary Search NOT always takes log(n) time to search an element, sometimes, we find element on first check.\n\nIn that case, Order of function would be 1.\n\nSo, our algorithm have:\n\nBest Case Scenario - best performance\n\nWorst Case Scenario - worst performance\n\nAverage Case Scenario - average performance\n\nFor this, we have a mathematical framework, named Asymptotic Notation.","type":"content","url":"/chapter-1-alogrithm#asymptotic-notation","position":25},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Defination","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl4","url":"/chapter-1-alogrithm#defination","position":26},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Defination","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"“It is a mathematical framework which is used to analyse an algorithm for its efficiency as input size (n) grows to infinity (\\infty)”\n\nThere are 3 types of Asymptotic Notations:-\n\nBig O notation (Worst Case)\n\nBig Omega (\\Omega) notation (Best Case)\n\nBig Theta (\\Theta) notation (Average Case)","type":"content","url":"/chapter-1-alogrithm#defination","position":27},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Big O Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl4","url":"/chapter-1-alogrithm#big-o-notation","position":28},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Big O Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"    Big O graph goes here\n\n    with caption below the graph as:\n    Here, n0 -> Threshold size of input (i.e. minimum input size, after which functions (algorithms) show their true behavior)\n    f(n) -> Our function (algorithm) which is under analysis.\n    g(n) -> Another function (algorithm) having higher rate of growth than our function (algorithm)\n\nDue to above graph, it is also known as Upper Bound.","type":"content","url":"/chapter-1-alogrithm#big-o-notation","position":29},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl5":"Defination","lvl4":"Big O Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl5","url":"/chapter-1-alogrithm#defination-1","position":30},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl5":"Defination","lvl4":"Big O Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"A function f(n) is said to be O(g(n)), if there exists positive constants, c & n_{0}, such that:0 \\leq f(n) \\leq c(g(n)); \\forall n \\geq n_{0}\n\nIt means, how bad our algorithm will perform, as input size grows.\n\nHigh rate of growth, is a bad sign, for an algorithm.","type":"content","url":"/chapter-1-alogrithm#defination-1","position":31},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Big Omege (\\Omega) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl4","url":"/chapter-1-alogrithm#big-omege-omega-notation","position":32},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Big Omege (\\Omega) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"    Big Omega graph goes here\n\n    with caption below the graph as:\n    Here, n0 -> Threshold size of input (i.e. minimum input size, after which functions (algorithms) show their true behavior)\n    f(n) -> Our function (algorithm) which is under analysis.\n    g(n) -> Another function (algorithm) having lower rate of growth than our function (algorithm)\n\nDue to above graph, it is also known as Lower Bound.","type":"content","url":"/chapter-1-alogrithm#big-omege-omega-notation","position":33},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl5":"Defination","lvl4":"Big Omege (\\Omega) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl5","url":"/chapter-1-alogrithm#defination-2","position":34},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl5":"Defination","lvl4":"Big Omege (\\Omega) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"A function f(n) is said to be \\Omega(g(n)), if there exists positive constants, c & n_{0}, such that:0 \\leq c(g(n)) \\leq f(n); \\forall n \\geq n_{0}\n\nIt means, how best our algorithm will perform, as input size grows.\n\nLower the rate of growth, is better.","type":"content","url":"/chapter-1-alogrithm#defination-2","position":35},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Big Theta (\\Theta) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl4","url":"/chapter-1-alogrithm#big-theta-theta-notation","position":36},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Big Theta (\\Theta) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"    Big Theta graph goes here\n\n    with caption below the graph as:\n    Here, n0 -> Threshold size of input (i.e. minimum input size, after which functions (algorithms) show their true behavior)\n    f(n) -> Our function (algorithm) which is under analysis.\n    g(n) -> Another function (algorithm) having lower rate of growth than our function (algorithm)\n\nDue to above graph, it is also known as Tight Bound.","type":"content","url":"/chapter-1-alogrithm#big-theta-theta-notation","position":37},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl5":"Defination","lvl4":"Big Theta (\\Theta) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"type":"lvl5","url":"/chapter-1-alogrithm#defination-3","position":38},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl5":"Defination","lvl4":"Big Theta (\\Theta) Notation","lvl3":"Asymptotic Notation","lvl2":"Performance Analysis"},"content":"A function f(n) is said to be \\Theta(g(n)), if there exists positive constants, c_{1}, c_{2} & n_{0}, such that:0 \\leq c_{1}(g(n)) \\leq f(n) \\leq c_{2}(g(n)); \\forall n \\geq n_{0}\n\nIt means, average performance of an algorithm.\n\nLies between Upper bound and Lower bound.","type":"content","url":"/chapter-1-alogrithm#defination-3","position":39},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Elementary Data Structures","lvl2":"Performance Analysis"},"type":"lvl3","url":"/chapter-1-alogrithm#elementary-data-structures","position":40},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl3":"Elementary Data Structures","lvl2":"Performance Analysis"},"content":"","type":"content","url":"/chapter-1-alogrithm#elementary-data-structures","position":41},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Stack","lvl3":"Elementary Data Structures","lvl2":"Performance Analysis"},"type":"lvl4","url":"/chapter-1-alogrithm#stack","position":42},{"hierarchy":{"lvl1":"Chapter 1: Algorithm","lvl4":"Stack","lvl3":"Elementary Data Structures","lvl2":"Performance Analysis"},"content":"    Stack Diagram goes here\n\nIt is a linear data structure, i.e. elements are accessed one after another, like we have place plates one over another in wedding.\n\nIt has only end for storing (Push) and removing (Pop) an element.\n\nIt operates on LIFO (Last In First Out) principle.\n\nStructure of a stack","type":"content","url":"/chapter-1-alogrithm#stack","position":43}]}